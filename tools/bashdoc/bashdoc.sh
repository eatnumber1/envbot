#!/bin/bash

# Make env sane
unset LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY
unset LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
unset LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
export LC_ALL=C
export LANG=C

VERSION="0.1.6"
HEADER="<!-- Generated by bashdoc version $VERSION, on $(date). -->"

#--------------------------
##	@Synopsis	Reads specialy formated shell scripts and creates docs
##	@Copyright	Copyright 2003, Paul Mahon
##	@License	GPL v2
##	Parses comments between lines of '#---'
##	Lines to be parsed start with ##. All tags start with @.
##	Lines without a tag are considered simple description of the section.
##	If the line following the comment block doesn't start with 'function'
##	the it's assumed that the comment is for the whole file. Only the first
##	non-function comment block will be used, the other will be ignored.
##	<p>
##	Multiple identical tags are allowed, the contents are appended and separated
##	with a space. @param tags are treated specials and are assumed to be in order.
##	<p>
##	There is an additional &lt;@function FUNCTION_NAME&gt; tag that can be embeded
##	in any bashdoc comment. It will be transformed into a link to that function.
##	Note, this will only work for functions that are defined in the same script.
##	<p><pre>
##	Usage:	[-p project] [-o directory] [-e tag] [--] script [ script ...]
##	'-p project'	Name of the project
##	'-o directory'	Specifies the directory you want the
##		resulting html to go into
##  '-e tag'	Only output if the block has this tag
##	'-q'		Quiet things down
##	'--'		No more arguments, only scripts
##	'script'	The script you want documented
##</pre>
##
#--------------------------

#--------------------------
##	@Arguments	-r: recursive, -o [directory]: output html
##	Parses arguments for this script
##	@Gobals	RECURSIVE, OUT_DIR
#--------------------------
function args()
{
	local retVal=0
	QUIET=0
	while true ; do
		case $1 in
			-p)
				PROJECT="$2"
				let retVal+=2
				shift 2
				;;
			-o)
				OUT_DIR=$2
				let retVal+=2
				shift 2
				;;
			--help|-h)
				usage
				exit 0
				;;
			--exclusive|-e)
				EXCLUSIVE="${2%%=*}"
				EXCLUSIVE_VAL="${2#*=}"
				let retVal+=2
				shift 2
				;;
			-q|--quiet)
				let QUIET+=1
				let retVal+=1
				shift 1
				;;
			--)
				let retVal++
				return $retVal
				;;
			-*)
				usage
				exit 0
				;;
			*)
				[ -e $1 ] && return $retVal
				echo "$1 doesn't exist."
				usage
				exit 1
				;;
		esac
	done
}

#-------------------------
##	Usage for this script
##	@Stdout	Usage information
#-------------------------
function usage()
{
cat <<- EOF
Usage: $(basename $0) [-p project] [-o directory] [--] script [ script ...]
	'-p project'     Name of the project
	'-o directory'   Specifies the directory you want the
	                 resulting html to go into
	'-e tag'         Only output if the block has this tag
	'-q'             Quiet the output
	'--'             No more arguments, only scripts
	'script'         The script you want documented

	Example: bashdoc.sh -p smgl -o docs/ /home/user/p4/sgl/devel/sorcery/var/lib/sorcery/modules/lib{misc,codex} bash2doc.sh
EOF
}


#--------------------------
##	Reads until it has read an entire comment block. A block starts with
##	<br><pre>#---</pre></br>
##	Alone on a line, and continues until the next
##	<br><pre>#---</pre></br>
##	All comment lines inside should have ## at the start or they
##	will be ignored.
##
##	@return 0 Possibly more blocks
##	@return 1 Unexpected end of file
##	@return 2 Expected end of file, no more blocks
##	@Stdin	Reads a chunk
##	@Stdout	Block with starting '##' removed
##	@Globals	paramDesc, retDesc, desc, block, split
#--------------------------
function get_comment_block()
{
	local inComment commentBlock lastLine=""
	commentBlock=""
	while read LINE ; do
		let srcLine++
		if [[ ${LINE:0:4} == '#---' ]] ; then
			if [[ $inComment ]] ; then
				echo "$commentBlock"
				return 0
			else
				inComment=yes
			fi
		elif [[ ${LINE:0:2} != '##' ]] && [[ $inComment ]] ; then
				[[ $QUIET -lt 1 ]] && echo "Line $srcLine of $FILE isn't a doc comment! Ignoring." >&2
		elif [[ $inComment ]] ; then
			commentBlock="$commentBlock"$'\n'${LINE####}
		fi
	done

	#If we make it out here, we hit the end of the file
	if [[ $commentBlock ]] ; then
		#If there is a comment block started, then it never ended
		[[ $QUIET -lt 2 ]] && echo "Unfinished comment block:"
		[[ $QUIET -lt 2 ]] && echo "$commentBlock"
		return 1
	else
		return 2
	fi
}


#-----------------------
##	Parses the comments from stdin. Also reads the (non-commented)
##	function name. Mostly uses <@function parse_block> and
##	<@function output_parsed_block> to do the read work.
##	@Stdin	Reads line after comment block
##	@Globals	paramDesc, retDesc, desc, block, split
#-----------------------
function parse_comments()
{

	#We use a lot of $( echo ... ) in here to trim the blanks

	local funcLine funcName
	paramDesc=()
	retDesc=()
	local FIRST_BLOCK="yes"
	local skipRead
	local outBlock=""
	local lastOutBlock=""
	while true ; do
		paramNames=()
		paramDesc=()
		split=()
		retDesc=()
		desc=""
		block=$( get_comment_block )
		[ $? -gt 0 ] && break

		if [[ $skipRead ]] ; then
			skipRead=""
		else
			funcLine=""
			funcName=""
			read funcLine
		fi
		if [[ ${funcLine%%[[:blank:]]*} == function ]] || [[ ${funcLine} =~ \(\)\ \{$ ]]; then
			funcName=$( echo ${funcLine#function} )
			funcName=$( echo ${funcName%%()*} )
		fi
		if [[ $funcName ]] || [[ $FIRST_BLOCK ]] ; then
			# Only bother with this block if it is a function block or
			#  the first script block

			#This fills in paramDesc[*], tag_*, retDesc
			parse_block
			lastOutBlock="$outBlock"
			outBlock=$(output_parsed_block)
			for i in ${!tag_*} ; do
				unset $i
			done

			if [[ $FIRST_BLOCK ]] && [[ ! $funcName ]] ; then
				FIRST_BLOCK=""
			fi

			if [[ $EXCLUSIVE ]] ; then
				local i="tag_${EXCLUSIVE}"
				if [[ ${!i} != $EXCLUSIVE_VAL ]] ; then
					echo "$funcName block ignored, no $EXCLUSIVE=$EXCLUSIVE_VAL tag." >&2
					for i in ${!tag_*} ; do
						unset $i
					done
					continue
				fi
			fi

			FUNC_LIST="$FUNC_LIST $funcName"
			echo "$outBlock"

		else
			[[ $QUIET -lt 2 ]] && echo "Ignoring non-first non-function comment block" >&2
			[[ $QUIET -lt 1 ]] && echo "$block" >&2
		fi
	done
}

#---------------------
##	Outputs the parsed information in a nice pretty format.
##	@Stdout	formated documentation
##	@Globals	paramDesc, retDesc, desc, block, split
#---------------------
function output_parsed_block()
{
	echo -e "<hr>"
	if [[ $funcName ]] ; then
		echo "<!-- Block for $funcName -->"
		echo "<dl>"
		echo "	<dt><a name='$funcName'><h2>function <strong>$funcName</strong>()</h2></a></dt>"
		echo "	<dd><ul>"
		for(( i=0; i<"${#paramDesc[@]}"; i++ )) ; do
			echo "		<li>\$$[i+1]: ${paramDesc[i]}</li>"
		done
		echo "	</ul></dd>"
		if [[ ${#retDesc[*]} -gt 0 ]] ; then
			echo "	<dt><h3>Returns:</h3></dt>"
			for(( i=0; i<"${#retDesc[@]}"; i++ )) ; do
				echo "		<li>${retDesc[i]}</li>"
			done
		fi

		for i in ${!tag_*} ; do
			echo "	<dt><h3>${i#tag_}</h3></dt>"
			echo "	<dd>${!i}</dd>"
			eval "unset $i"
		done
		[[ $desc ]] && echo "	<dt><h3>Description</h3></dt><dd>$desc</dd>"
		echo "</dl>"
	else
		echo '<!-- Header for whole script -->'
		echo "<dl>"
		echo "	<dt><h1><strong>$FILE</strong></h1></dt>"
		echo "	<dd>$desc</dd>"
		echo "$desc" >> $SCRIPT_DESC

		for i in ${!tag_*} ; do
			echo "	<dt><h3>${i#tag_}</h3></dt>"
			echo "	<dd>${!i}</dd>"
			unset $i
		done
		echo "</dl>"
	fi

}

#---------------
##	Does the real work of the parsing. Tags start with @. Special
##	tags are @return and @param. Doc lines without a tag are
##	considered description.
##	@Globals	paramDesc, retDesc, desc, block, split
##	@Test	many line
##	@Test	test tag
#---------------
function parse_block()
{
	local tag
	local backIFS="$IFS"
	IFS=$'\n'
	for LINE in $block; do
		IFS="$backIFS"
		LINE=$( echo $LINE )
		if [[ ${LINE:0:1} == '@' ]] ; then
			split_tag split $LINE
			case ${split} in
				@param) 	#paramNames[${#paramNames[*]}]=${split[1]}
					paramDesc=( "${paramDesc[@]}" "${split[1]}" )
					;;
				@return)
					retDesc=( "${retDesc[@]}" "${split[1]}" )
					;;
				@*) tag=${split[0]#@}
					local i="tag_${tag}"
					if [[ ${!i} ]] ; then
						eval "tag_${tag}=\"\${tag_${tag}}"$'\n'"${split[1]}\""
					else
						eval "tag_${tag}=\"${split[1]}\""
					fi
					;;
				*)	echo "We shouldn't get here... it was a tag, but not a tag?" >&2
					;;
			esac
		else
			desc="$desc"$'\n'"$LINE"
		fi
	done
	IFS="$backIFS"
}

#----------------
##	Splits a line that starts with a tag into tag and data.
##	@param	Variable you want the result put into. Array is format is ( tag, data ).
##	@param	Tag
##	@param	Data
##	@Globals	The variable in $1 will get the results
#----------------
function split_tag()
{
	local out="${1}"			;	shift
	local tag=$( echo ${1} )	;	shift
#	local key=$( echo ${1} )	;	shift
	local value=$( echo $* | sed 's/"/\\"/g')
	eval "$out=( \"$tag\" \"${value}\" )"
}

#--------------------
##	Outputs a header for script pages
##	@Stdout	html header
##	@param	Script name
#--------------------
function script_header()
{
cat <<- EOF > $OUT_FILE
	<!DOCTYPE "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
	<html>
	$HEADER
	<head>
		<title>$1 - $PROJECT</title>
	</head>
	<body>
	<p align=right>
	<a href="script_list.html">Script Index</a>
	</p>
EOF
}

# Initialise project variables
OUT_DIR=$( dirname $0 )
args "$@"
shift $?
[[ $OUT_DIR ]] || OUT_DIR="."


while [ $# -gt 0 ] ; do

	echo "Parsing $FILE" >&2
	#Initialise vars for this src
	FILE=$1
	shift
	OUT_FILE=${FILE#/}									#Remove leading /
	OUT_FILE="$OUT_DIR/${OUT_FILE//\//.}.html"
	FUNC_FILE="${OUT_FILE%.html}.funcs"
	SCRIPT_DESC="${OUT_FILE%.html}.desc"
	FUNC_LIST=""

	#Start this src's html file
	script_header "$1"

	# Parse and write out function list
	{
		parse_comments < $FILE
		echo "$FUNC_LIST" > $FUNC_FILE
	} | sed	-e 's!<@[[:blank:]]*function \([^,>]*\)[[:blank:]]*>!<a href="#\1">\1</a>!g' \
			-e 's!<@[[:blank:]]*function \([^,>]*\),[[:blank:]]*\([^>]*\)[[:blank:]]*>!<a href="\1#\2">\1</a>!g' >> $OUT_FILE
	#Close off the html for this src
	cat <<- EOF >> $OUT_FILE
		</body>
		</html>
	EOF

done #Go on to next src

#Now for tying the scripts all together
pushd $OUT_DIR >/dev/null

# Start page that will have all the function calls
cat <<- EOF > function_list.html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
$HEADER
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>Functions of $PROJECT</title>
</head>
<body>
	<p>
EOF

# Merge function lists of all sources, sort by function name
for i in *.funcs ; do
	for f in $( cat $i ) ; do
		echo "$f <a href=\"${i%.funcs}.html#$f\" target=\"main\">$f</a><br />"
	done
done | sort | cut -d' ' -f2- >> function_list.html

# Close off the html for the global function list
cat <<-	EOF >> function_list.html
	</p>
</body>
</html>
EOF

# Start the list of scripts
TITLE="Scripts"
[[ $PROJECT ]] && TITLE="$PROJECT Script Documentation"
cat <<- EOF > script_list.html
	<!DOCTYPE "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
	<html>
	$HEADER
	<head>
		<title>Scripts of $PROJECT</title>
	</head>
	<body>
	<h1>$TITLE</h1>
	<hr>
	<dl>
EOF

# List all the sources + descriptions, sort by script dir/name
for i in *.funcs ; do
	name=${i%.funcs}
	echo "${name}"
done | sort | while read LINE ; do
	echo "<dt><a href=\"${LINE}.html\">$LINE</a></dt>"
	echo "<dd>"
	cat ${LINE}.desc 2>/dev/null || { [[ $QUIET -lt 2 ]] && echo "$LINE has no description." >&2; }
	echo "</dd>"
done >> script_list.html

# Close off the html for the global script list
cat <<-	EOF >> script_list.html
	</dl>
	</body>
	</html>
EOF

# Create the index file for the whole shbang
cat <<- EOF > index.html
	<html>
	<head>
	$HEADER
		<title>BashDoc - $PROJECT</title>
	</head>
	<frameset COLS="20%,*">
		<frame src=function_list.html name=function_list>
		<frame src=script_list.html name=main>
	</frameset>
	</html>
EOF

# Remove the temporary .desc files, leave the .func files, someone may want them later.
rm *.desc
popd >/dev/null
