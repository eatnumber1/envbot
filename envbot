#!/usr/bin/env bash
###########################################################################
#                                                                         #
#  envbot - an IRC bot in bash                                            #
#  Copyright (C) 2007  Arvid Norlander                                    #
#                                                                         #
#  This program is free software: you can redistribute it and/or modify   #
#  it under the terms of the GNU General Public License as published by   #
#  the Free Software Foundation, either version 3 of the License, or      #
#  (at your option) any later version.                                    #
#                                                                         #
#  This program is distributed in the hope that it will be useful,        #
#  but WITHOUT ANY WARRANTY; without even the implied warranty of         #
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          #
#  GNU General Public License for more details.                           #
#                                                                         #
#  You should have received a copy of the GNU General Public License      #
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.  #
#                                                                         #
###########################################################################
config_file="bot_settings.sh"
# Where to load libraries from
library_dir="lib"

# Set some variables to make bot work sane
# For example tr + some LC_COLLATE = breaks in some cases.
unset LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY
unset LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
unset LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
export LC_ALL=C
export LANG=C
# If you need something else, override in config...
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
# To make set -x more usable
export PS4=$'(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]} : '

if [[ $EUID -eq 0 ]]; then
	echo "ERROR: Don't run envbot as root. Please run it under a normal user. Really."
	exit 2
fi

# This is needed when we run the bot with env -i as recommended.
declare -r tmp_home="$(mktemp -dt envbot.home.XXXXXXXXXX)"
# I don't want to end up with rm -rf $HOME...
# Temp one until the next "stage" of trap gets loaded (at connect)
trap 'rm -rvf "$tmp_home"; exit 1' TERM INT
export HOME="$tmp_home"
# Now create a temp function to quit in a way that cleans up temp stuff until we
# are up enough to use the normal function bot_quit.
envbot_quit() {
	rm -rf "$tmp_home"
	exit "$1"
}

force_verbose=0

# Store command line for later use
command_line="$@"

# Current config version.
declare -r config_current_version=13

print_cmd_help() {
	echo 'envbot - A modular IRC bot in bash.'
	echo ''
	echo 'Usage: envbot [OPTION]...'
	echo ''
	echo 'Options:'
	echo "  -c, --config file       Use file instead of the default $config_file as config file."
	echo "      --libdir directory  Use directory instead of the default $library_dir as library directory."
	echo '  -v, --verbose           Force verbose output even if config_log_stdout is 0.'
	echo '      --help              Display this help and exit'
	echo '  -V, --version           Output version information and exit'
	echo ''
	echo 'Examples:'
	echo '  envbot                  Runs envbot with default options.'
	echo '  envbot -c bot.config    Runs envbot with the config bot.config.'
	echo ''
	echo 'Report bugs to http://kuonet.org/~anmaster/envbot/trac/simpleticket'
	envbot_quit 0
}

print_version() {
	echo 'envbot 0.0.1-alpha - A modular IRC bot in bash.'
	echo ''
	echo 'Copyright (C) 2007 Arvid Norlander'
	echo 'Copyright (C) 2007 EmErgE'
	echo 'This is free software; see the source for copying conditions.  There is NO'
	echo 'warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.'
	echo ''
	echo 'Written by Arvid Norlander and EmErgE.'
	envbot_quit 0
}

if [ $# -gt 0 ]; then # there are arguments to the command
	while [ $# -gt 0 ]; do
		case "$1" in
			'--help'|'-help'|'--usage'|'-usage'|'-h')
				print_cmd_help
				;;
			'--config'|'-c')
				config_file="$2"
				shift 2
				;;
			'--libdir')
				library_dir="$2"
				shift 2
				;;
			'--verbose'|'-v')
				force_verbose=1
				shift 1
				;;
			'--version'|'-V')
				print_version
				;;
			*)
				print_cmd_help
				;;
		esac
	done
fi

echo "Loading... Please wait"

if [ ! -r "$config_file" ]; then
	echo "ERROR: Can't read config file ${config_file}."
	echo "Check that is really there and correct permissions are set."
	echo "If you used --config to specify name of config file, check that you spelled it correctly."
	envbot_quit 1
fi

echo "Loading config"
source "$config_file"
if [[ $? -ne 0 ]]; then
	echo "Error: couldn't load config from bot_settings.sh"
	envbot_quit 1
fi

# This is hackish, it should be in config.sh (config_validate)
# The reason is that we need to load transport before libraries:
if [ -z "$config_version" ]; then
	echo "ERROR: YOU MUST SET THE CORRECT config_version IN THE CONFIG"
	envbot_quit 1
fi
if [ $config_version -ne $config_current_version ]; then
	echo "ERROR: YOUR config_version IS $config_version BUT THE BOT'S CONFIG VERSION IS $config_current_version."
	echo "PLEASE UPDATE YOUR CONFIG. Check bot_settings.sh.example for current format."
	envbot_quit 1
fi

if [[ $force_verbose -eq 1 ]]; then
	config_log_stdout='1'
fi

# Must be checked here and not in validate_config because of
# loading order.
if [ ! -d "${config_transport_dir}" ]; then
	echo "ERROR: The transport directory ${config_transport_dir} doesn't seem to exist"
	envbot_quit 1
fi
if [ ! -r "${config_transport_dir}/${config_transport}.sh" ]; then
	echo "ERROR: The transport ${config_transport} doesn't seem to exist"
	envbot_quit 1
fi
echo "Loading transport"
source "${config_transport_dir}/${config_transport}.sh"

if ! transport_check_support; then
	echo "ERROR: The transport reported it can't work on this system."
	echo "Please consult documentation for the transport module you are using."
	envbot_quit 1
fi

echo "Loading library functions"
# Load library functions.
libraries="log send feedback numerics channels parse \
           access misc config modules server"
for library in $libraries; do
	source "${library_dir}/${library}.sh"
done
unset library

config_validate
log_init

# Now logging functions can be used.

# Status variables

echo "Loading modules"
# Load modules
modules_load_from_config


while true; do
	for module in $modules_before_connect; do
		module_${module}_before_connect
	done
	server_connect
	trap 'bot_quit "ctrl-C"' TERM INT
	for module in $modules_after_connect; do
		module_${module}_after_connect
	done


	while transport_read_line ; do #-d $'\n'
		log_raw_in "$line"
		for module in $modules_on_raw; do
			module_${module}_on_raw "$line"
			if [[ $? -ne 0 ]]; then
				# TODO: Check that this does what it should.
				continue 2
			fi
		done
		if [[ $line =~ ^:${server_name}\ ([0-9]{3})\ ([^ ]+)\ (.*) ]]; then
			# this is a numeric
			numeric="${BASH_REMATCH[1]}"
			numericdata="${BASH_REMATCH[3]}"
			server_handle_numerics "$numeric" "${BASH_REMATCH[2]}" "$numericdata"
			for module in $modules_on_numeric; do
				module_${module}_on_numeric "$numeric" "$numericdata"
				if [[ $? -ne 0 ]]; then
					break
				fi
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+PRIVMSG\ ([^:]*)(.*) ]]; then
			sender="${BASH_REMATCH[1]}"
			target="${BASH_REMATCH[2]}"
			query="${BASH_REMATCH[3]}"
			query="${query#*:}"
			for module in $modules_on_PRIVMSG; do
				module_${module}_on_PRIVMSG "$sender" "$target" "$query"
				if [[ $? -ne 0 ]]; then
					break
				fi
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+NOTICE\ ([^:]*)(.*) ]]; then
			sender="${BASH_REMATCH[1]}"
			target="${BASH_REMATCH[2]}"
			query="${BASH_REMATCH[3]}"
			query="${query#*:}"
			for module in $modules_on_NOTICE; do
				module_${module}_on_PRIVMSG "$sender" "$target" "$query"
				if [[ $? -ne 0 ]]; then
					break
				fi
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+TOPIC\ (#[^ ]+)(\ :(.*))? ]]; then
			sender="${BASH_REMATCH[1]}"
			channel="${BASH_REMATCH[2]}"
			topic="${BASH_REMATCH[4]}"
			for module in $modules_on_TOPIC; do
				module_${module}_on_TOPIC "$sender" "$channel" "$topic"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+MODE\ (#[^ ]+)\ (.*) ]]; then
			sender="${BASH_REMATCH[1]}"
			channel="${BASH_REMATCH[2]}"
			modes="${BASH_REMATCH[3]}"
			for module in $modules_on_channel_MODE ; do
				module_${module}_on_channel_MODE "$sender" "$channel" "$modes"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+NICK\ (.*) ]]; then
			sender="${BASH_REMATCH[1]}"
			newnick="${BASH_REMATCH[2]}"
			# Check if it was our own nick
			server_handle_nick "$sender" "$newnick"
			for module in $modules_on_NICK; do
				module_${module}_on_NICK "$sender" "$newnick"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+JOIN\ :(.*) ]]; then
			sender="${BASH_REMATCH[1]}"
			channel="${BASH_REMATCH[2]}"
			# Check if it was our own nick that joined
			channels_handle_join "$sender" "$channel"
			for module in $modules_on_JOIN; do
				module_${module}_on_JOIN "$sender" "$channel"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+PART\ (#[^ ]+)(\ :(.*))? ]]; then
			sender="${BASH_REMATCH[1]}"
			channel="${BASH_REMATCH[2]}"
			reason="${BASH_REMATCH[4]}"
			# Check if it was our own nick that joined
			channels_handle_part "$sender" "$channel" "$reason"
			for module in $modules_on_JOIN; do
				module_${module}_on_PART "$sender" "$channel" "$reason"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+KICK\ (#[^ ]+)\ ([^ ]+)(\ :(.*))? ]]; then
			sender="${BASH_REMATCH[1]}"
			channel="${BASH_REMATCH[2]}"
			kicked="${BASH_REMATCH[3]}"
			reason="${BASH_REMATCH[5]}"
			# Check if it was our own nick that joined
			channels_handle_kick "$sender" "$channel" "$kicked" "$reason"
			for module in $modules_on_KICK; do
				module_${module}_on_KICK "$sender" "$channel" "$kicked" "$reason"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+QUIT(\ :(.*))? ]]; then
			sender="${BASH_REMATCH[1]}"
			reason="${BASH_REMATCH[3]}"
			for module in $modules_on_QUIT; do
				module_${module}_on_QUIT "$sender" "$reason"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+KILL\ ([^ ]*)\ :([^ ]*)\ \((.*)\) ]]; then
			sender="${BASH_REMATCH[1]}"
			target="${BASH_REMATCH[2]}"
			path="${BASH_REMATCH[3]}"
			reason="${BASH_REMATCH[4]}"
			# I don't think we need to check if we were the target or not,
			# the bot doesn't need to care as far as I can see.
			for module in $modules_on_KILL; do
				module_${module}_on_KILL "$sender" "$target" "$path" "$reason"
			done
		elif [[ $line =~ ^[^:] ]] ;then
			server_handle_ping "$line"
			if [[ "$line" =~ ^ERROR\ :(.*) ]]; then
				error="${BASH_REMATCH[1]}"
				log_stdout "Got ERROR from server: $error"
				for module in $modules_on_server_ERROR; do
						module_${module}_on_server_ERROR "$error"
				done
			fi
		fi
	done

	log "DIED FOR SOME REASON"
	transport_disconnect
	server_connected=0
	for module in $modules_after_disconnect; do
		module_${module}_after_disconnect
	done
	# Don't reconnect right away. We might get throttled and other nasty stuff.
	sleep 10
done
rm -rf tmp_home
