#!/usr/bin/env bash
###########################################################################
#                                                                         #
#  envbot - an irc bot in bash                                            #
#  Copyright (C) 2007  Arvid Norlander                                    #
#                                                                         #
#  This program is free software: you can redistribute it and/or modify   #
#  it under the terms of the GNU General Public License as published by   #
#  the Free Software Foundation, either version 3 of the License, or      #
#  (at your option) any later version.                                    #
#                                                                         #
#  This program is distributed in the hope that it will be useful,        #
#  but WITHOUT ANY WARRANTY; without even the implied warranty of         #
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          #
#  GNU General Public License for more details.                           #
#                                                                         #
#  You should have received a copy of the GNU General Public License      #
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.  #
#                                                                         #
###########################################################################
config_file="bot_settings.sh"

print_cmd_help() {
	echo 'envbot - A modular IRC bot in bash.'
	echo "Syntax:"
	echo "  --config file   Use file instead of the default $config_file as config file."
	exit 0
}
print_version() {
	echo 'envbot 0.0.0.1-bzr'
	echo 'A modular IRC bot in bash.'
	echo "Copyright (C) 2007 Arvid Norlander"
	echo "Copyright (C) 2007 EmErgE"
	echo "This is free software; see the source for copying conditions.  There is NO"
	echo "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
	exit 0
}

if [ $# -gt 0 ]; then # there are arguments to the command
	while [ $# -gt 0 ]; do
		case "$1" in
			'--help'|'-help'|'--usage'|'-usage'|'-h')
				print_cmd_help
				;;
			'--config'|'-c')
				config_file="$2"
				shift 2
				;;
			*)
				print_cmd_help
				;;
		esac
	done
fi

echo "Loading... Please wait"

if [ ! -r "$config_file" ]; then
	echo "ERROR: Can't read config file ${config_file}."
	echo "Check that is really there and correct permissions are set."
	echo "If you used --config to specify name of config file, check that you spelled it correctly."
	exit 1
fi

echo "Loading config"
source "$config_file"
if [[ $? -ne 0 ]]; then
	echo "Error: couldn't load config from bot_settings.sh"
	exit 1
fi

config_current_version=9

# Must be checked here and not in validate_config because of
# loading order.
if [ ! -r "transport/${config_transport}.sh" ]; then
	echo "ERROR: The transport ${config_transport} doesn't seem to exist"
	exit 1
fi
echo "Loading transport"
source "transport/${config_transport}.sh"

if ! transport_check_support; then
	echo "ERROR: The transport reported it can't work on this system."
	echo "Please consult documentation for the transport module you are using."
	exit 1
fi

echo "Loading library functions"
# Load library functions.
source lib/log.sh
source lib/send.sh
source lib/feedback.sh
source lib/numerics.sh
source lib/channels.sh
source lib/parse.sh
source lib/access.sh
source lib/misc.sh
source lib/modules.sh
source lib/server.sh

validate_config
log_init

# Now logging functions can be used.

# Status variables
nick_current=""
connected=0


IRC_CONNECT(){
	connected=0
	on_nick=1
	# HACK: Clean up if we are aborted, replaced after connect with one that sends QUIT
	trap 'transport_disconnect; exit 1' TERM INT
	log_stdout "Connecting..."
	transport_connect "$config_server" "$config_server_port" "$config_server_ssl" "$config_server_bind" || return 1
	while transport_read_line; do
		# Check with modules first, needed so we don't skip them.
		for module in $modules_on_connect; do
			module_${module}_on_connect "$line"
		done
		# Part of motd, that goes to dev null.
		if  [[ $(cut -d' ' -f2 <<< "$line") == $numeric_RPL_MOTD  ]]; then
			continue
		fi
		log_raw_in "$line"
		# Start of motd, note that we don't display that.
		if  [[ $(cut -d' ' -f2 <<< "$line") == $numeric_RPL_MOTDSTART  ]]; then
			log "Motd is not displayed in log"
		elif  [[ $(cut -d' ' -f2 <<< "$line") == $numeric_RPL_YOURHOST  ]]; then
			if [[ $line =~ Your\ host\ is\ ([^ ,]*)  ]]; then # just to get the server name, this should always be true
				server_name="${BASH_REMATCH[1]}"
			fi
		elif  [[ $(cut -d' ' -f2 <<< "$line") == $numeric_RPL_MYINFO ]]; then
			server_004="$(cut -d' ' -f4- <<< "$line")"
			server_004=$(tr -d $'\r\n' <<< "$server_004")  # Get rid of ending newline
		elif  [[ $(cut -d' ' -f2 <<< "$line") == $numeric_RPL_ISUPPORT ]]; then
			server_005="$server_005 $(cut -d' ' -f4- <<< "$line")"
			server_005=$(tr -d $'\r\n' <<< "$server_005") # Get rid of newlines
			server_005="${server_005/ :are supported by this server/}" # Get rid of :are supported by this server
			server_handle_005 "$line"
		elif [[ $line =~ "Looking up your hostname" ]]; then
			log_stdout "logging in as $config_firstnick..."
			send_nick "$config_firstnick"
			# FIXME: THIS IS HACKISH AND MAY BREAK
			nick_current="$config_firstnick"
			# If a server password is set, send it.
			[[ $config_server_passwd ]] && send_raw_flood "PASS $config_server_passwd"
			send_raw_flood "USER $config_ident 0 * :${config_gecos}"
		fi
		server_handle_ping "$line"
		if [[ $(cut -d' ' -f2 <<< "$line") == $numeric_ERR_NICKNAMEINUSE  ]]; then # Nick in use.
			server_handle_nick_in_use
		elif [[ $(cut -d' ' -f2 <<< "$line") == $numeric_ERR_ERRONEUSNICKNAME  ]]; then # Erroneous Nickname Being Held...
			server_handle_nick_in_use
		elif [[ $(cut -d' ' -f2 <<< "$line") == $numeric_RPL_ENDOFMOTD  ]]; then # 376 = End of motd
			sleep 1
			log_stdout 'Connected'
			connected=1
			break
		fi
	done;
}

echo "Loading modules"
# Load modules
modules_load_from_config


while true; do
	for module in $modules_before_connect; do
		module_${module}_before_connect
	done
	IRC_CONNECT
	trap 'quit_bot "ctrl-C"' TERM INT
	for module in $modules_after_connect; do
		module_${module}_after_connect
	done


	while transport_read_line ; do #-d $'\n'
		log_raw_in "$line"
		for module in $modules_on_raw; do
			module_${module}_on_raw "$line"
			if [[ $? -ne 0 ]]; then
				# TODO: Check that this does what it should.
				continue 2
			fi
		done
		if [[ $line =~ ^:${server_name}\ ([0-9]{3})\ ([^ ]+)\ (.*) ]]; then
			# this is a numeric
			numeric="${BASH_REMATCH[1]}"
			numericdata="${BASH_REMATCH[3]}"
			server_handle_numerics "$numeric" "${BASH_REMATCH[2]}" "$numericdata"
			for module in $modules_on_numeric; do
				module_${module}_on_numeric "$numeric" "$numericdata"
				if [[ $? -ne 0 ]]; then
					break
				fi
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+PRIVMSG\ ([^:]*)(.*) ]]; then
			sender="${BASH_REMATCH[1]}"
			target="${BASH_REMATCH[2]}"
			query="${BASH_REMATCH[3]}"
			query="${query#*:}"
			for module in $modules_on_PRIVMSG; do
				module_${module}_on_PRIVMSG "$sender" "$target" "$query"
				if [[ $? -ne 0 ]]; then
					break
				fi
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+NOTICE\ ([^:]*)(.*) ]]; then
			sender="${BASH_REMATCH[1]}"
			target="${BASH_REMATCH[2]}"
			query="${BASH_REMATCH[3]}"
			query="${query#*:}"
			for module in $modules_on_NOTICE; do
				module_${module}_on_PRIVMSG "$sender" "$target" "$query"
				if [[ $? -ne 0 ]]; then
					break
				fi
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+TOPIC\ (#[^ ]+)(\ :(.*))? ]]; then
			sender="${BASH_REMATCH[1]}"
			channel="${BASH_REMATCH[2]}"
			topic="${BASH_REMATCH[4]}"
			for module in $modules_on_TOPIC; do
				module_${module}_on_TOPIC "$sender" "$channel" "$topic"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+MODE\ (#[^ ]+)\ (.*) ]]; then
			sender="${BASH_REMATCH[1]}"
			channel="${BASH_REMATCH[2]}"
			modes="${BASH_REMATCH[3]}"
			for module in $modules_on_channel_MODE ; do
				module_${module}_on_channel_MODE "$sender" "$channel" "$modes"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+NICK\ (.*) ]]; then
			sender="${BASH_REMATCH[1]}"
			newnick="${BASH_REMATCH[2]}"
			# Check if it was our own nick
			server_handle_nick "$sender" "$newnick"
			for module in $modules_on_NICK; do
				module_${module}_on_NICK "$sender" "$newnick"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+JOIN\ :(.*) ]]; then
			sender="${BASH_REMATCH[1]}"
			channel="${BASH_REMATCH[2]}"
			# Check if it was our own nick that joined
			channels_handle_join "$sender" "$channel"
			for module in $modules_on_JOIN; do
				module_${module}_on_JOIN "$sender" "$channel"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+PART\ (#[^ ]+)(\ :(.*))? ]]; then
			sender="${BASH_REMATCH[1]}"
			channel="${BASH_REMATCH[2]}"
			reason="${BASH_REMATCH[4]}"
			# Check if it was our own nick that joined
			channels_handle_part "$sender" "$channel" "$reason"
			for module in $modules_on_JOIN; do
				module_${module}_on_PART "$sender" "$channel" "$reason"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+KICK\ (#[^ ]+)\ ([^ ]+)(\ :(.*))? ]]; then
			sender="${BASH_REMATCH[1]}"
			channel="${BASH_REMATCH[2]}"
			kicked="${BASH_REMATCH[3]}"
			reason="${BASH_REMATCH[5]}"
			# Check if it was our own nick that joined
			channels_handle_kick "$sender" "$channel" "$kicked" "$reason"
			for module in $modules_on_KICK; do
				module_${module}_on_KICK "$sender" "$channel" "$kicked" "$reason"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+QUIT(\ :(.*))? ]]; then
			sender="${BASH_REMATCH[1]}"
			reason="${BASH_REMATCH[3]}"
			for module in $modules_on_QUIT; do
				module_${module}_on_QUIT "$sender" "$reason"
			done
		elif [[ "$line" =~ ^:([^ ]*)[\ ]+KILL\ ([^ ]*)\ :([^ ]*)\ \((.*)\) ]]; then
			sender="${BASH_REMATCH[1]}"
			target="${BASH_REMATCH[2]}"
			path="${BASH_REMATCH[3]}"
			reason="${BASH_REMATCH[4]}"
			# I don't think we need to check if we were the target or not,
			# the bot doesn't need to care as far as I can see.
			for module in $modules_on_KILL; do
				module_${module}_on_KILL "$sender" "$target" "$path" "$reason"
			done
		elif [[ $line =~ ^[^:] ]] ;then
			server_handle_ping "$line"
			if [[ "$line" =~ ^ERROR\ :(.*) ]]; then
				error="${BASH_REMATCH[1]}"
				log_stdout "Got ERROR from server: $error"
				for module in $modules_on_server_ERROR; do
						module_${module}_on_server_ERROR "$error"
				done
			fi
		fi
	done

	log "DIED FOR SOME REASON"
	transport_disconnect
	connected=0
	for module in $modules_after_disconnect; do
		module_${module}_after_disconnect
	done
	# Don't reconnect right away. We might get throttled and other nasty stuff.
	sleep 10
done
